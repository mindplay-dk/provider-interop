# Service Provider Integration

This project provides a means of integrating
[PSR-11 containers](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md)
at the provider-level.

**STATUS:** the namespace/interface/method-names are still subject to change, but the interface/method
signatures are unlikely to change.

### Comparison with [`container-interop/service-provider`](https://github.com/container-interop/service-provider) 

The approach proposed here is radically different from standardizing the service-providers themselves,
which is a much harder problem.

What this project defines is a simpler, more high-level exchange of entries, accomplishing much the
same thing as standardizing the providers themselves, while removing the decision for module-authors
to write "standard" vs "proprietary" service-providers, allowing full use of all of the features of
a selected container-implementation, and avoids compromising the internal integrity of
individual containers.

The `ServiceProviderInterface` of `container-interop/service-provider` places control with the
receiving container, by returning a list of entries in a loosely defined format. The specification
includes a set of rules about how these entries must be treated by the receiving container.

By contrast, the `ServiceProviderInterface` defined by this package places control with the provider
itself, by introducing a more formal contract, in the form of a second interface, which defines a
"service registry" facet of a receiving container (or container-factory, builder, adapter, etc.)

Unlike `container-interop/service-provider`, where the developer implements `ServiceProviderInterface`
when implementing a provider, the `ServiceProviderInterface` defined by this project is intended to
be implemented by the container-implementation itself:
 
- Implementing the `ServiceProviderInterface` enables the container to act as a service-provider,
  e.g. makes it capable of *exporting* it's entries to a service-registry.
  
- Implementing the `ServiceRegistryInterface` enables the container to act as a service-registry,
  e.g. makes it capable to *importing* entries exported by an external service-provider.

In other words, the service-provider and service-registry facets provide a synchronous contract,
enabling container (or factory/builder) implementations to act as either providers or recipients
of a set of container entries.

As noted [here](https://github.com/container-interop/container-interop/issues/55#issuecomment-285939658),
these interfaces may afford better separation of concerns, and may enable more patterns and concepts
to be implemented, such as the notion of public vs private entries, and more flexibility in scenarios
involving multiple containers.

## Usage

To implement a self-contained "module", you will most likely want to select a PSR-11 container-implementation
that is capable of acting as a service-provider, e.g. implements `ServiceProviderInterface` to export
it's own entries to a receiving container.

In the following example, assume that `YourModuleFactory` internally creates and bootstraps a container
of your choice, and that container implements `ServiceProviderInterface`.

Also, assume that `$my_container` is an instance of a container that is capable of acting as a service-registry,
e.g. implements `ServiceRegistryInterface` to import entries from the container generated by your "module".

In the following example, I am importing container entries being exported by a container that your module provides:

```php
// I create an instance of your module's factory:

$your_module_factory = new YourModuleFactory();

// I use it to create a bootstrapped instance of whatever container your module uses:

$your_container = $your_module_factory->createContainer();

// I assume that your container can act as a service-provider:

assert($your_container instanceof ServerProviderInterface);

// I assert that my own container can act as a service-registry:

assert($my_container instanceof ServiceRegistryInteface);

// I can now import the container-entries from your container into my container:

$your_container->registerWith($my_container);
```

Note that a service-provider can be anything - it doesn't have to be a container, and does not for that
matter necessarily depend on PSR-11 at all. In very simple scenarios, where your package does not benefit
from using a container to bootstrap itself internally, you can implement `ServiceProviderInterface` directly. 

## Implementation

To implement the `ServiceProviderInterface` facet in a container, the container-implementation must internally
enumerate the entries it wishes to export, and inject them into the target service-registry.

For example, the implementation might iterate over a private map of `callable` entries with a
function-signature that is proprietary to the container-implementation, and export plain, zero-argument
`callable` functions to the target container.

```php
class MyContainer implements ContainerInterface, ServiceProviderInterface
{
    public function registerWith(ServiceRegistryInterface $registry)
    {
        foreach ($this->listIdentifiers() as $id) {
            $registry->register($id, function () use ($id) {
                return $this->get($id);
            });
        }
    }
    
    // ...
}
```

Note that the implementation of `listIdentifiers()` is omitted from this example, as the implementation is
going to depend on internal implementation details of the given container.

Implementation of the `ServiceRegistryInterface` facet in a container is dependent on the nature of that container.

A mutable container-implementation must provide a means of injecting entries into it's internal service-registry,
e.g. implementing the `register()` method, which should be trivial to implement in any container. The `$resolver`
function provided to a service-registry via the `register()` method should be stored internally in the container,
and may be invoked (with zero arguments) to resolve the entry, e.g. during a call to `ContainerInterface::get()`.

In practice, many container-implementations use a two-stage life-cycle, in which a container-factory or
"builder" is created prior to generating immutable container instances - in these container-implementations,
the target container-factory/builder must implement the `ServiceRegistryInterface`, and the source container
itself would implement the `ServiceProviderInterface`.
